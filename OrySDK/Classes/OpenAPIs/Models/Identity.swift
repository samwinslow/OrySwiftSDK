//
// Identity.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** An [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) represents a (human) user in Ory. */
public struct Identity: Codable, JSONEncodable, Hashable {

    /** CreatedAt is a helper struct field for gobuffalo.pop. */
    public var createdAt: Date?
    /** Credentials represents all credentials that can be used for authenticating this identity. */
    public var credentials: [String: IdentityCredentials]?
    /** ID is the identity's unique identifier.  The Identity ID can not be changed and can not be chosen. This ensures future compatibility and optimization for distributed stores such as CockroachDB. */
    public var id: String
    /** NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable- */
    public var metadataAdmin: AnyCodable?
    /** NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable- */
    public var metadataPublic: AnyCodable?
    /** RecoveryAddresses contains all the addresses that can be used to recover an identity. */
    public var recoveryAddresses: [RecoveryIdentityAddress]?
    /** SchemaID is the ID of the JSON Schema to be used for validating the identity's traits. */
    public var schemaId: String
    /** SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.  format: url */
    public var schemaUrl: String
    public var state: IdentityState?
    public var stateChangedAt: Date?
    /** Traits represent an identity's traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in `schema_url`. */
    public var traits: AnyCodable?
    /** UpdatedAt is a helper struct field for gobuffalo.pop. */
    public var updatedAt: Date?
    /** VerifiableAddresses contains all the addresses that can be verified by the user. */
    public var verifiableAddresses: [VerifiableIdentityAddress]?

    public init(createdAt: Date? = nil, credentials: [String: IdentityCredentials]? = nil, id: String, metadataAdmin: AnyCodable? = nil, metadataPublic: AnyCodable? = nil, recoveryAddresses: [RecoveryIdentityAddress]? = nil, schemaId: String, schemaUrl: String, state: IdentityState? = nil, stateChangedAt: Date? = nil, traits: AnyCodable?, updatedAt: Date? = nil, verifiableAddresses: [VerifiableIdentityAddress]? = nil) {
        self.createdAt = createdAt
        self.credentials = credentials
        self.id = id
        self.metadataAdmin = metadataAdmin
        self.metadataPublic = metadataPublic
        self.recoveryAddresses = recoveryAddresses
        self.schemaId = schemaId
        self.schemaUrl = schemaUrl
        self.state = state
        self.stateChangedAt = stateChangedAt
        self.traits = traits
        self.updatedAt = updatedAt
        self.verifiableAddresses = verifiableAddresses
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case createdAt = "created_at"
        case credentials
        case id
        case metadataAdmin = "metadata_admin"
        case metadataPublic = "metadata_public"
        case recoveryAddresses = "recovery_addresses"
        case schemaId = "schema_id"
        case schemaUrl = "schema_url"
        case state
        case stateChangedAt = "state_changed_at"
        case traits
        case updatedAt = "updated_at"
        case verifiableAddresses = "verifiable_addresses"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(credentials, forKey: .credentials)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(metadataAdmin, forKey: .metadataAdmin)
        try container.encodeIfPresent(metadataPublic, forKey: .metadataPublic)
        try container.encodeIfPresent(recoveryAddresses, forKey: .recoveryAddresses)
        try container.encode(schemaId, forKey: .schemaId)
        try container.encode(schemaUrl, forKey: .schemaUrl)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(stateChangedAt, forKey: .stateChangedAt)
        try container.encode(traits, forKey: .traits)
        try container.encodeIfPresent(updatedAt, forKey: .updatedAt)
        try container.encodeIfPresent(verifiableAddresses, forKey: .verifiableAddresses)
    }
}

