//
// Subscription.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct Subscription: Codable, JSONEncodable, Hashable {

    public enum CurrentInterval: String, Codable, CaseIterable {
        case monthly = "monthly"
        case yearly = "yearly"
    }
    public var createdAt: Date
    /** The currently active interval of the subscription monthly Monthly yearly Yearly */
    public var currentInterval: CurrentInterval
    /** The currently active plan of the subscription */
    public var currentPlan: String
    /** The ID of the stripe customer */
    public var customerId: String
    /** The ID of the subscription */
    public var id: String
    public var intervalChangesTo: String?
    public var ongoingStripeCheckoutId: String?
    /** Until when the subscription is payed */
    public var payedUntil: Date
    public var planChangesAt: Date?
    public var planChangesTo: String?
    /** For `collection_method=charge_automatically` a subscription moves into `incomplete` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an `active` state. If the first invoice is not paid within 23 hours, the subscription transitions to `incomplete_expired`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.  A subscription that is currently in a trial period is `trialing` and moves to `active` when the trial period is over.  If subscription `collection_method=charge_automatically` it becomes `past_due` when payment to renew it fails and `canceled` or `unpaid` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts.  If subscription `collection_method=send_invoice` it becomes `past_due` when its invoice is not paid by the due date, and `canceled` or `unpaid` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of `unpaid`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices. */
    public var status: String
    public var updatedAt: Date

    public init(createdAt: Date, currentInterval: CurrentInterval, currentPlan: String, customerId: String, id: String, intervalChangesTo: String?, ongoingStripeCheckoutId: String? = nil, payedUntil: Date, planChangesAt: Date? = nil, planChangesTo: String?, status: String, updatedAt: Date) {
        self.createdAt = createdAt
        self.currentInterval = currentInterval
        self.currentPlan = currentPlan
        self.customerId = customerId
        self.id = id
        self.intervalChangesTo = intervalChangesTo
        self.ongoingStripeCheckoutId = ongoingStripeCheckoutId
        self.payedUntil = payedUntil
        self.planChangesAt = planChangesAt
        self.planChangesTo = planChangesTo
        self.status = status
        self.updatedAt = updatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case createdAt = "created_at"
        case currentInterval = "current_interval"
        case currentPlan = "current_plan"
        case customerId = "customer_id"
        case id
        case intervalChangesTo = "interval_changes_to"
        case ongoingStripeCheckoutId = "ongoing_stripe_checkout_id"
        case payedUntil = "payed_until"
        case planChangesAt = "plan_changes_at"
        case planChangesTo = "plan_changes_to"
        case status
        case updatedAt = "updated_at"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(currentInterval, forKey: .currentInterval)
        try container.encode(currentPlan, forKey: .currentPlan)
        try container.encode(customerId, forKey: .customerId)
        try container.encode(id, forKey: .id)
        try container.encode(intervalChangesTo, forKey: .intervalChangesTo)
        try container.encodeIfPresent(ongoingStripeCheckoutId, forKey: .ongoingStripeCheckoutId)
        try container.encode(payedUntil, forKey: .payedUntil)
        try container.encodeIfPresent(planChangesAt, forKey: .planChangesAt)
        try container.encode(planChangesTo, forKey: .planChangesTo)
        try container.encode(status, forKey: .status)
        try container.encode(updatedAt, forKey: .updatedAt)
    }
}

